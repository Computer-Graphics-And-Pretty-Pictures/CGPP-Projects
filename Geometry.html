<html>
	<head>
		<title>Lighting</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }

		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/noise.js"></script>
		<script>

			// @author PWhiddy

			// A container to place our objects into
			var scene = new THREE.Scene();
			/*
			* PerspectiveCamera( fov, aspect, near, far )
			* fov — Camera  vertical field of view.
			* aspect — Camera  aspect ratio.
			* near — Camera near plane. (Objects outside the near and far plane won't be rendered)
			* far — Camera far plane.
			*/
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			// Move camera back so we are looking at the origin
			camera.position.z = 5;

			// The threejs webgl renderer
			var renderer = new THREE.WebGLRenderer({antialias: true});
			// Tell renderer the dimensions of our screen
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			// Attach renderer to DOM element 
			document.body.appendChild( renderer.domElement );

			// adding orbit controls to allow camera movement
			var controls = new THREE.OrbitControls( camera, renderer.domElement );

			// Create our objects geometry with built-in mesh knot algorithim
			//var geometry = new THREE.TorusKnotGeometry( 10, 3, 192, 96);

			var geometry = new THREE.Geometry();

			var vertCount = 20;
			var faceCount = 10;
			
			for (var i = 0; i < vertCount; i++) {
				geometry.vertices.push( new THREE.Vector3(Math.sin(i), Math.cos(i), 0));
			//	geometry.vertices.push( new THREE.Vector3( i % 5, Math.floor(i/5), 0));

				geometry.colors.push( new THREE.Color( Math.sin(i*0.2)*0.5+0.5, 
													   Math.cos(i*0.3)*0.5+0.5, 
													   Math.sin(i*0.4)*0.5+0.5));
			}
			for (var i = 0; i < faceCount; i++) {
				geometry.faces.push( new THREE.Face3( i, vertCount-i-2, i+3 ));
			}

			geometry.computeBoundingSphere();
			

			/*
			geometry = new THREE.PlaneGeometry(50,50,50,50);

			for (var i = 0; i < geometry.vertices.length; i++ ) {
				geometry.vertices[i].add(new THREE.Vector3( 0, 0, fractalNoise(i*0.002)*8 ));
			}
			geometry.computeVertexNormals();

			*/

			console.log(geometry);
			// The material properties of our object
			var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors, side: THREE.DoubleSide } ); // color is in hexidecimal

			// Use our geometry and material to create a mesh (What's a mesh? https://en.wikipedia.org/wiki/Polygon_mesh)
			var mesh = new THREE.Line( geometry, material );
			// Add mesh to the scene
			scene.add( mesh );

			/* Create a point light source with color 0xdddddd, intesity 0.5 */
			var pointLight = new THREE.PointLight(0xdddddd, 0.5);
			scene.add(pointLight);
			// Adjust light position to nicely illuminate object
			pointLight.position.y = 5;
			pointLight.position.x = 5;
			//*/

			/* Ambient lighting - try disabling one of the lights to see each's contribution */
			var hemisphereLight = new THREE.HemisphereLight(0x8899cc, 0x334455);
			scene.add(hemisphereLight);
			//*/
			
			// Our rendering loop
			var render = function () {
				// Rendering function is called each time the 
				// browser requests a new frame
				requestAnimationFrame( render );
				controls.update();
				// Rotate our object
				mesh.rotation.x += 0.005;
				mesh.rotation.y += 0.005;

				// Render our scene
				renderer.render(scene, camera);
			};

			render();
		</script>
	</body>
</html>