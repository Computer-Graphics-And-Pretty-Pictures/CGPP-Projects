<!DOCTYPE html>
<html lang="en">
	<head>
		<title>FBM Vertex Shader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://uwc.graphics" target="_blank">CGPP</a> FBM Triangle Shredder</div>
		<div id="progressBar">
		  <div id="bar"></div>
		</div>
		<script src="js/MobileAndTabletCheck.js"></script>
		<script src="js/three.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/stats.min.js"></script>
	    <script src="js/OrbitControls.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex" src=>

			precision mediump float;
			precision mediump int;

			uniform mat4 modelViewMatrix; // optional
			uniform mat4 projectionMatrix; // optional
			uniform float time;
			uniform float amplitude;

			uniform vec2 mouse;
			uniform vec3 cameraPos;
			uniform float pSize;

			attribute vec3 position;
			attribute vec3 normal;
			attribute vec4 colors;

			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec4 vColor;


			/// NOISE CODE 
			//  noise from https://www.shadertoy.com/view/XsX3zB
		    /* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */
			vec3 random3(vec3 c) {
				float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
				vec3 r;
				r.z = fract(512.0*j);
				j *= .125;
				r.x = fract(512.0*j);
				j *= .125;
				r.y = fract(512.0*j);
				return r-0.5;
			}

		    /* skew constants for 3d simplex functions */
		    const float F3 =  0.3333333;
		    const float G3 =  0.1666667;
		    /* 3d simplex noise */
		    float simplex3d(vec3 p) {
				/* 1. find current tetrahedron T and it's four vertices */
				/* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */
				/* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/
				/* calculate s and x */
				vec3 s = floor(p + dot(p, vec3(F3)));
				vec3 x = p - s + dot(s, vec3(G3));
				/* calculate i1 and i2 */
				vec3 e = step(vec3(0.0), x - x.yzx);
				vec3 i1 = e*(1.0 - e.zxy);
				vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				/* x1, x2, x3 */
				vec3 x1 = x - i1 + G3;
				vec3 x2 = x - i2 + 2.0*G3;
				vec3 x3 = x - 1.0 + 3.0*G3;
				/* 2. find four surflets and store them in d */
				vec4 w, d;
				/* calculate surflet weights */
				w.x = dot(x, x);
				w.y = dot(x1, x1);
				w.z = dot(x2, x2);
				w.w = dot(x3, x3);
				/* w fades from 0.6 at the center of the surflet to 0.0 at the margin */
				w = max(0.6 - w, 0.0);
				/* calculate surflet components */
				d.x = dot(random3(s), x);
				d.y = dot(random3(s + i1), x1);
				d.z = dot(random3(s + i2), x2);
				d.w = dot(random3(s + 1.0), x3);
				/* multiply d by w^4 */
				w *= w;
				w *= w;
				d *= w;
				/* 3. return the sum of the four surflets */
				return dot(d, vec4(52.0)) + 0.5;
		    }

		    float fractalNoise(vec3 p)
		    {
		        float f = 0.0;
		        float a = 0.5;
		        p = p + vec3(0.0, 0.5, 0.0) * time * 0.02;

		        
		        
		        for (float i = 0.0; i < 5.0; i++ ) {

		            f += a * simplex3d(p);
		            p *= 2.0 ;
		            a *= 0.5;
		        }
		        return f;
		    }
		    
	  		/// END NOISE CODE

		void main()	{

			vPosition = position;//mix(position, positionB, abMix);
			vColor = colors;

	        vec3 p = position;
	        float dist = 0.01*(p.x*p.x+p.y*p.y);
	       // p.z += 15.0*sin(dist+time)/(dist+1.0);
	        //vec3 noise = vec3(fractalNoise(p.xyz),fractalNoise(p.zyx),fractalNoise(p.yzx))-0.5;
	        //p += 4.0*noise;
	        vNormal = normal;

	        //float dist = distance(p, vec3(mouse * 300.0-300.0, 0.0));
	        // p.x += ;
	        //p = mix(p, vec3(mouse * 300.0-300.0, 0.0), 1.0/dist);
	        //p.z += 20000.0 / (1.0+dist);

			gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );
			float d = distance(p, cameraPos);
			gl_PointSize = pSize/(d);//4.0;//pointSize;

		}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			precision mediump float;
			precision mediump int;

			uniform float time;

			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec4 vColor;

			void main()	{
				/*vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));
				
        		color *= dot(normalize(vNormal),lightDir);
        		float audioColor = colorContour * (audio[4] + audio[5] + audio[6] * audio[7] * 3.0)  * 0.0001;

				// color.r += sin( vPosition.x * 10.0 + time ) * 0.5;
				color.a = opacity;*/

				//vec4 color = vec4(vColor, 1.0);

				gl_FragColor = vec4( vColor );
				
			}

		</script>

		

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer, controls;

			var pointLight, skyBox;

			var gui, params;
			var sound, playAudio, volume, geometry, material, mouse, noiseShape, noiseGeometry;


			init();
			console.log(scene.children[0]);
			gui.closed = true;
			animate();		

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 5, 15000 );
				camera.position.set(0, -50, 0);
				// camera.position.set(250,-557, 253);

				scene = new THREE.Scene();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				mouse = new THREE.Vector2();

				initGui();

				var dim = 35;
				var spacing = 4;
		        vertCount = dim*dim*dim;
		        geometry = new THREE.BufferGeometry();

		        verts = new Float32Array(vertCount*3);
		        for (var i=0; i<vertCount; i++) {
		        	verts[3*i+0] = spacing*(i%dim-dim/2);
		        	verts[3*i+1] = spacing*Math.floor(i/dim)%dim-dim/2;
		        	verts[3*i+2] = spacing*Math.floor(i/(dim*dim))-dim/2;
		        }

		        normals = new Float32Array(vertCount*3);
		        for (var i=0; i<verts.length; i++) {
		        	normals[i] = 0;
		        }

		        vels = new Float32Array(vertCount*3);
		        for (i of vels) i = 0.0;

		        colors = new Float32Array(vertCount*4*4);
		        for (var i=0; i<vertCount*4; i++) {
		        	colors[4+i+0] = Math.random();
		        	colors[4+i+1] = Math.random();
		        	colors[4+i+2] = Math.random();
		        	colors[4*i+3] = 1.0;
		        }

		        geometry.addAttribute( "position",
		        	new THREE.BufferAttribute(verts, 3) );

		        geometry.addAttribute( "normal", 
		        	new THREE.BufferAttribute(normals, 3));

		        geometry.addAttribute( "colors",
		        	new THREE.BufferAttribute(colors, 4));

				material = new THREE.RawShaderMaterial( {

					uniforms: {
						time: { value: 1.0 },
                        cameraPos : {value: camera.position},
						amplitude : {value: params.amplitude },
						pSize: {value : params.pointSize},
						mouse : {value : mouse }

					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
					side: THREE.DoubleSide,
					transparent: false
				} );

				points = new THREE.Points( geometry, material );
				scene.add(points);


				pointLight = new THREE.PointLight(0xFFFFFF, 1.0);
				scene.add(pointLight);
        
				var skyBoxMat = new THREE.MeshStandardMaterial( { roughness:0.4, color: 0xFFFFFF, emissive: 0x000000, emissiveIntensity:0, side: THREE.DoubleSide } );
				var skyBoxGeom = new THREE.SphereGeometry(5500, 32, 32);
				skyBox = new THREE.Mesh(skyBoxGeom, skyBoxMat);
				scene.add(skyBox);

				renderer = new THREE.WebGLRenderer({ antialias : true });
				renderer.setClearColor( 0x101010 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;
				renderer.autoClearColor = false;
				renderer.autoClearDepth = false;
				renderer.autoClearStencil = false;

				// scene.fog = new THREE.Fog(0x000000, 500, 5000);
				container.appendChild( renderer.domElement );


				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.dampingFactor = 0.9;  
				controls.zoomSpeed = 0.3;
				controls.rotateSpeed = 0.3;	
				controls.maxDistance = 5000;
        
				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function initGui() {
				params = {
					amplitude : 25,
					force: 0.45,
					damping: 0.9,
					distSoft: 10.0,
					pointSize: 1400.0
				};
				gui = new dat.GUI();
				gui.add(params, "force", 0.0, 10.5);
				gui.add(params, "damping", 0.0, 0.995);
				gui.add(params, "distSoft", 1.0, 80.0);
				gui.add(params, "pointSize", 200, 9000);
			}

			function onDocumentMouseMove(event) {
				mouse.x = ( event.clientX / window.innerWidth );
				mouse.y = ( event.clientY / window.innerHeight );
			}			

			function onWindowResize( event ) {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				render();
				stats.update();

			}

			function render() {

				var time = 0.005*performance.now();
				
				points.material.uniforms.time.value = time;
				points.material.uniforms.cameraPos.value = camera.position;
				points.material.uniforms.pSize.value = params.pointSize;

				var rForce = params.force*params.force;
				var pos = points.geometry.attributes.position.array;
				var cols = points.geometry.attributes.colors.array;
				for (var i=0; i <vertCount; i++) {
					var a = 3*i;
					var b = 3*((i+1)%vertCount);
					dx = pos[a+0] - pos[b+0];
					dy = pos[a+1] - pos[b+1];
					dz = pos[a+2] - pos[b+2];
					var dist = dx*dx+dy*dy+dz*dz+params.distSoft;

					vels[a+0] -= rForce*dx/dist;
					vels[a+1] -= rForce*dy/dist;
					vels[a+2] -= rForce*dz/dist;

					vels[a+0] *= params.damping;
					vels[a+1] *= params.damping;
					vels[a+2] *= params.damping;

					var c = 4*i;
					cols[c+0] = 10.0*vels[a+0];
					cols[c+1] = 10.0*vels[a+1];
					cols[c+2] = 10.0*vels[a+2];

					pos[a+0] += vels[a+0];
					pos[a+1] += vels[a+1];
					pos[a+2] += vels[a+2];

				}

				points.geometry.attributes.position.needsUpdate = true;
				points.geometry.attributes.colors.needsUpdate = true;
				
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
